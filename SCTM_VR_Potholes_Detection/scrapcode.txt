const int MAX_VALUE = 255;
const int MAX_TYPE = 4;
const int MAX_BINARY_VALUE = 255;
const int BIN_THS_VALUE = 100;

//int threshold_value = 100;
//Mat BW = Mat();
//cvtColor(image, BW, COLOR_RGB2GRAY);
//Mat bin = Mat();
//threshold(BW, bin, 100, MAX_BINARY_VALUE , BINARY);
//Mat mid = Mat();
//medianBlur(bin, mid, 3);
//Mat dilated = Mat();
//Mat str_el = getStructuringElement(MORPH_ELLIPSE, Size(2 * 1 + 1, 2 * 1 + 1), Point(1, 1));
//dilate(mid, dilated, str_el);
//namedWindow("display window", WINDOW_AUTOSIZE);    // create a window for display.
//imshow("display window", dilated);                     // show our image inside it.
//waitKey(0);
//bilateralFilter(tmp1, tmp2, blur_strength, blur_strength*2, blur_strength*0.5);


struct Box {
	Point2i bottom_right;
	Point2i top_left;

	bool contains(Point2i);
};

struct Annotation {

	string image_path;
	string image_name;
	vector<Box> objects;

};

bool Box::contains(Point2i p) {
	return p.x <= this->bottom_right.x && p.x >= this->top_left.x && p.y <= this->bottom_right.y && p.y >= this->top_left.y;
}

void set_format(string & of_file_name_path, string to_new_format, bool use_separator = true) {
	size_t image_format_offset_begin = of_file_name_path.find_last_of(".");
	string image_format = of_file_name_path.substr(image_format_offset_begin);
	size_t image_format_offset_end = image_format.length() + image_format_offset_begin;

	of_file_name_path.replace(image_format_offset_begin, image_format_offset_end, (use_separator ? "." : "") + to_new_format);
}

void images_load(const vector<Annotation> & annotations, vector< Mat > & loaded_images)
{
	for (size_t i = 0; i < annotations.size(); ++i)
	{
		Mat img = imread(annotations[i].image_path, IMREAD_COLOR);
		if (img.empty())
		{
			cout << annotations[i].image_path << " is invalid!" << endl;
		}
		else {
			loaded_images.push_back(img);
		}
	}
}

void load_from_annotations(const string & filename, vector<Annotation> & annotations) 
{
	ifstream infile(filename);
	string line;
	while (std::getline(infile, line))
	{

		istringstream iss(line);
		vector<string> results(istream_iterator<string>{iss}, istream_iterator<string>());
		vector<Box> locators;

		for (size_t i = 2; i < results.size(); i += 4) 
		{

			Point2i bottom_right(stoi(results[i]), stoi(results[i + 1]));
			Point2i top_left(stoi(results[i + 2]), stoi(results[i + 3]));

			Box b = { bottom_right, top_left };

			locators.push_back(b);
		}

		string image_name = results[0].substr(results[0].find_last_of("\\")+1);

		clog << image_name << endl;

		struct Annotation a = {results[0], image_name, locators };

		annotations.push_back(a);
	}
}

void build_training_structures(const vector<Mat> & images, const vector<Annotation> & annotations, vector<Mat> & training_set, vector<Mat> & probability_mask) {
	
	vector<Mat> bin_masks;
	build_binaries(images, annotations, bin_masks);

	for (size_t i = 0; i < images.size(); ++i) 
	{

		Mat img = images[i];
		training_set.push_back(img.reshape(img.rows*img.cols, 1));

		vector<Box> boxes = annotations[i].objects;
		Mat mask(img.rows, img.cols, CV_32SC1);

		for (size_t row = 0; row < mask.rows; ++row) 
		{
			for (size_t col = 0; col < mask.cols; ++col) 
			{
				for (size_t j = 0; j < boxes.size(); ++j) 
				{
					if (boxes[j].isInside(Point2i(row, col))) //  && bin_masks[i].at<int>(row, col) == 255
					{
						mask.at<int>(row, col) = 255;
					}
					else {
						mask.at<int>(row, col) = 0;
					}
				}
			}
		}

		probability_mask.push_back(mask.reshape(mask.rows*mask.cols, 1));

		string image_path	= annotations[i].image_path;
		string mask_path	= image_path.insert(image_path.find_last_of("\\") + 1, "masks\\");
		mask_path			= mask_path.insert(mask_path.find_last_of("."), "_mask");

		size_t image_format_offset_begin	= mask_path.find_last_of(".");
		string image_format					= mask_path.substr(image_format_offset_begin);
		size_t image_format_offset_end		= image_format.length() + image_format_offset_begin;

		string mask_name = mask_path.replace(image_format_offset_begin, image_format_offset_end, ".bmp");

		imwrite(mask_name, mask);

		clog << "Saved mask of " << annotations[i].image_path << " as " << mask_name << endl;
	}
}

/*
Mat BW = Mat();
cvtColor(image, BW, COLOR_RGB2GRAY);

Mat bin = Mat();
threshold(BW, bin, BIN_THS_VALUE, MAX_BINARY_VALUE , THRESH_BINARY_INV | THRESH_OTSU);
*/
/*****************************************************************************************************************/

//Ptr<AKAZE> akaze_descr = AKAZE::create();
//vector<KeyPoint> kps;
//Mat descriptor = Mat();
//string akaze_descr_save_path = data_root_path + "keypoints/akaze/" + image_name;
//set_format(akaze_descr_save_path, "yml");
//FlannBasedMatcher flann_matcher= FlannBasedMatcher();
//clog << "Compuing Akaze descritor for " << image_name << " ... ";
//akaze_descr->detectAndCompute(image, Mat(), kps, descriptor);
//clog << akaze_descr_save_path << endl;
//akaze_descr->write(akaze_descr_save_path);
//clog << "Saved akaze descriptor of " << image_name << " as " << akaze_descr_save_path << endl;

//Mat kps_image;
//drawKeypoints(image, kps, kps_image, Scalar::all(-1), DrawMatchesFlags::DEFAULT);
//imshow("Keypoints", kps_image);
//waitKey(0);

void labeling(const vector<Mat> & images, Mat & training_set, Mat & classes_set, const vector<Annotation> & annotations = vector<Annotation>(), bool use_annotations = false)
{
	for (size_t i = 0; i < images.size(); ++i)
	{

		Mat image = images[i];
		vector<Box> windows = annotations[i].objects;
		Mat classes(image.rows, image.cols, CV_32FC1);

		for (size_t row = 0; row < image.rows; ++row)
		{

			for (size_t col = 0; col < image.cols; ++col)
			{

				for (size_t w = 0; w < windows.size(); ++w)
				{

					if (windows[w].contains(Point2i(row, col)))
					{
						classes.at<int>(row, col) = CLASSES::POTHOLE;
					}
					else
					{
						classes.at<int>(row, col) = CLASSES::BACKGROUND;
					}
				}
			}
		}

		image.convertTo(image, CV_32FC1);

		training_set.push_back(image.reshape(1, 1));
		classes_set.push_back(classes.reshape(1, 1));
	}
}

int resize_all_in(const string folder, const int width = 1280, const int height = 720) {

	vector<String> fn;
	glob(folder + "\\*", fn);

	cout << "Found " << fn.size() << " images..." << endl;

	for (int i = 0; i < fn.size(); i++)
	{
		string file_name = fn[i];
		Mat img = imread(file_name, IMREAD_COLOR);

		if (img.empty())
		{
			cerr << "invalid image: " << file_name << endl;
			continue;
		}
		else
		{
			cout << "Loaded image " << file_name << endl;

			Mat dst;
			resize(img, dst, Size(width, height));

			imwrite(folder + "\\scaled\\" + file_name.substr(file_name.find_last_of("\\")), dst);
		}
	}

	return 1;
}

Mat get_hogdescriptor_visual_image(const Mat& or_img, const vector< float>& dscr, const Size win, const Size cell, const int bins = 9, const int scale = 1, const double grad_viz = 5, const bool isGrayscale = false, bool onlyMaxGrad = true)
{
	Mat visual_image;
	if (scale == 1) {
		resize(or_img, visual_image, Size(or_img.cols*scale, or_img.rows*scale));
	}
	
	if (isGrayscale) {
		cvtColor(visual_image, visual_image, CV_GRAY2BGR);
	}
	
	// dividing 180ï¿½ into 9 bins, how large (in rad) is one bin?
	float radRangeForOneBin = 3.14 / (float)bins;

	// prepare data structure: 9 orientation / gradient strenghts for each cell
	int cells_in_x_dir = win.width / cell.width;
	int cells_in_y_dir = win.height / cell.height;
	int totalnrofcells = cells_in_x_dir * cells_in_y_dir;
	float*** gradientStrengths = new float**[cells_in_y_dir];
	int** cellUpdateCounter = new int*[cells_in_y_dir];
	for (int y = 0; y< cells_in_y_dir; y++)
	{
		gradientStrengths[y] = new float*[cells_in_x_dir];
		cellUpdateCounter[y] = new int[cells_in_x_dir];
		for (int x = 0; x< cells_in_x_dir; x++)
		{
			gradientStrengths[y][x] = new float[bins];
			cellUpdateCounter[y][x] = 0;

			for (int bin = 0; bin< bins; bin++)
				gradientStrengths[y][x][bin] = 0.0;
		}
	}

	// nr of blocks = nr of cells - 1
	// since there is a new block on each cell (overlapping blocks!) but the last one
	int blocks_in_x_dir = cells_in_x_dir - 1;
	int blocks_in_y_dir = cells_in_y_dir - 1;

	// compute gradient strengths per cell
	int descriptorDataIdx = 0;
	int cellx = 0;
	int celly = 0;

	for (int blockx = 0; blockx< blocks_in_x_dir; blockx++)
	{
		for (int blocky = 0; blocky< blocks_in_y_dir; blocky++)
		{
			// 4 cells per block ...
			for (int cellNr = 0; cellNr< 4; cellNr++)
			{
				// compute corresponding cell nr
				int cellx = blockx;
				int celly = blocky;
				if (cellNr == 1) celly++;
				if (cellNr == 2) cellx++;
				if (cellNr == 3)
				{
					cellx++;
					celly++;
				}

				for (int bin = 0; bin< bins; bin++)
				{
					float gradientStrength = dscr[descriptorDataIdx];
					descriptorDataIdx++;

					gradientStrengths[celly][cellx][bin] += gradientStrength;

				} // for (all bins)


				  // note: overlapping blocks lead to multiple updates of this sum!
				  // we therefore keep track how often a cell was updated,
				  // to compute average gradient strengths
				cellUpdateCounter[celly][cellx]++;

			} // for (all cells)


		} // for (all block x pos)
	} // for (all block y pos)


	// compute average gradient strengths
	for (int celly = 0; celly< cells_in_y_dir; celly++)
	{
		for (int cellx = 0; cellx< cells_in_x_dir; cellx++)
		{

			float NrUpdatesForThisCell = (float)cellUpdateCounter[celly][cellx];

			// compute average gradient strenghts for each gradient bin direction
			for (int bin = 0; bin< bins; bin++)
			{
				gradientStrengths[celly][cellx][bin] /= NrUpdatesForThisCell;
			}
		}
	}


	cout << "descriptorDataIdx = " << descriptorDataIdx << endl;

	// draw cells
	for (int celly = 0; celly< cells_in_y_dir; celly++)
	{
		for (int cellx = 0; cellx< cells_in_x_dir; cellx++)
		{
			int drawX = cellx * cell.width;
			int drawY = celly * cell.height;

			int mx = drawX + cell.width / 2;
			int my = drawY + cell.height / 2;

			rectangle(visual_image,
				Point(drawX*scale, drawY*scale),
				Point((drawX + cell.width)*scale,
				(drawY + cell.height)*scale),
				CV_RGB(100, 100, 100),
				1);

			if (onlyMaxGrad) {
				double maxGrad = 0.0; int idx = 0;
				
				for (int bin = 0; bin < bins; bin++) {
					if (gradientStrengths[celly][cellx][bin] > maxGrad) {
						maxGrad = gradientStrengths[celly][cellx][bin];
						idx = bin;
					}
				}

				// no line to draw?
				if (maxGrad == 0)
					continue;

				float currRad = idx * radRangeForOneBin + radRangeForOneBin / 2;

				float dirVecX = cos(currRad);
				float dirVecY = sin(currRad);
				float maxVecLen = cell.width / 2;
				float scale = grad_viz; // just a visual_imagealization scale,
										  // to see the lines better

										  // compute line coordinates
				float x1 = mx - dirVecX * maxGrad * maxVecLen * scale;
				float y1 = my - dirVecY * maxGrad * maxVecLen * scale;
				float x2 = mx + dirVecX * maxGrad * maxVecLen * scale;
				float y2 = my + dirVecY * maxGrad * maxVecLen * scale;

				// draw gradient visual_imagealization
				line(visual_image,
					Point(x1*scale, y1*scale),
					Point(x2*scale, y2*scale),
					CV_RGB(0, 0, 255),
					1);
			}
			else {
				// draw in each cell all 9 gradient strengths
				for (int bin = 0; bin < bins; bin++)
				{
					float currentGradStrength = gradientStrengths[celly][cellx][bin];

					// no line to draw?
					if (currentGradStrength == 0)
						continue;

					float currRad = bin * radRangeForOneBin + radRangeForOneBin / 2;

					float dirVecX = cos(currRad);
					float dirVecY = sin(currRad);
					float maxVecLen = cell.width / 2;
					float scale = grad_viz; // just a visual_imagealization scale,
											  // to see the lines better

											  // compute line coordinates
					float x1 = mx - dirVecX * currentGradStrength * maxVecLen * scale;
					float y1 = my - dirVecY * currentGradStrength * maxVecLen * scale;
					float x2 = mx + dirVecX * currentGradStrength * maxVecLen * scale;
					float y2 = my + dirVecY * currentGradStrength * maxVecLen * scale;

					// draw gradient visual_imagealization
					line(visual_image,
						Point(x1*scale, y1*scale),
						Point(x2*scale, y2*scale),
						CV_RGB(0, 0, 255),
						1);

				} // for (all bins)
			}

		} // for (cellx)
	} // for (celly)


	  // don't forget to free memory allocated by helper data structures!
	for (int y = 0; y< cells_in_y_dir; y++)
	{
		for (int x = 0; x< cells_in_x_dir; x++)
		{
			delete[] gradientStrengths[y][x];
		}
		delete[] gradientStrengths[y];
		delete[] cellUpdateCounter[y];
	}
	delete[] gradientStrengths;
	delete[] cellUpdateCounter;

	return visual_image;

}

void HOG() {

	vector<Mat> set;
	Mat classes;
	Mat training_set;
	vector<string> ids;

	load_from_directory(positive_training_set_directory, ids, set, classes, CLASSES::POTHOLE);
	//load_from_directory(negative_training_set_directory, ids, set, classes, CLASSES::NORMAL);

	const Size window(640, 480), block(64, 64), block_stride(16, 16), cell(16, 16), stride(8, 8), padding(0, 0);
	const int bin = 9;
	cv::HOGDescriptor hog = HOGDescriptor(window, block, block_stride, cell, bin);
	vector<Mat> descriptors;

	for (int i = 0; i < set.size(); ++i) {

		vector<float> ft;
		vector<Point> locs;
		Mat image = set[i];
		//Mat edges;

		cvtColor(image, image, CV_RGB2GRAY);

		/*
		string canny_save_loc = training_set_directory + (classes.at<int>(i) == 1 ? "Positive\\" : "Negative\\") + "Canny\\" + ids[i];
		Canny(image, edges, 15, 70);
		imwrite(canny_save_loc, edges);
		*/

		cout << "Resizing image number " << i << " @ " << window << endl;
		resize(image, image, window);

		cout << "Computing HOG Descriptor...";
		hog.compute(image, ft, stride, padding, locs);

		Mat d = get_hogdescriptor_visual_image(image, ft, window, cell);

		//descriptors.push_back(d);
		string dscr_save_loc = training_set_directory + (classes.at<int>(i) == 1 ? "Positive\\" : "Negative\\") + "HOG\\" + ids[i];
		cout << "Saving Descriptor @ " << dscr_save_loc << endl;

		imwrite(dscr_save_loc, d);
	}
}